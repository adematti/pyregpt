#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "define.h"
#include "common.h"
#include "kernels.h"

#define NCOMP 5

static GaussLegendreQ gauss_legendre_q;
static GaussLegendreMu gauss_legendre_mu;
#pragma omp threadprivate(gauss_legendre_q,gauss_legendre_mu)
static Precision precision_q = {.n=600,.min=-1.,.max=-1.,.interpol=POLY};
static Precision precision_mu = {.n=300,.min=-1.,.max=1.,.interpol=POLY};
static const size_t INDEX_A[5][2] = {{0,0},{0,1},{1,1},{1,2},{2,2}};
static const size_t INDEX_B[12][3] = {{0,0,0},{0,0,1},{0,1,0},{0,1,1},{1,0,0},{1,0,1},{1,1,0},{1,1,1},{2,0,1},{2,1,0},{2,1,1},{3,1,1}};
static const size_t SHAPE_A[2] = {3,3};
static const size_t SHAPE_B[2] = {4,3};



void kernel_A_1loop(histo_t* r,histo_t* x,histo_t* kernel)
{
	kernel[0] = -r[3]/7.*(x[1]+6*x[3]+r[2]*x[1]*(-3+10*x[2])+r[1]*(-3+x[2]-12*x[4]));		// m,n = 1,1
	kernel[1] = r[4]/14.*(x[2]-1)*(-1+7*r[1]*x[1]-6*x[2]);									// m,n = 1,2
	kernel[2] = r[3]/14.*(r[2]*x[1]*(13-41*x[2])-4*(x[1]+6*x[3])+r[1]*(5+9*x[2]+42*x[4]));	// m,n = 2,2
	kernel[3] = kernel[1];																	// m,n = 2,3
	kernel[4] = r[3]/14.*(1-7*r[1]*x[1]+6*x[2])*(-2*x[1]+r[1]*(-1+3*x[2]));					// m,n = 3,3
}

void kernel_tA_1loop(histo_t* r,histo_t* x,histo_t* kernel)
{
	kernel[0] = 1./7.*(x[1]+r[1]-2*r[1]*x[2])*(3*r[1]+7*x[1]-10*r[1]*x[2]);
	kernel[1] = r[1]/14.*(x[2]-1)*(3*r[1]+7*x[1]-10*r[1]*x[2]);
	kernel[2] = 1./14.*(28*x[2]+r[1]*x[1]*(25-81*x[2])+r[2]*(1-27*x[2]+54*x[4]));
	kernel[3] = r[1]/14.*(1-x[2])*(r[1]-7*x[1]+6*r[1]*x[2]);
	kernel[4] = 1./14.*(r[1]-7*x[1]+6*r[1]*x[2])*(-2*x[1]-r[1]+3*r[1]*x[2]);
}

void kernel_a_1loop(histo_t* r,histo_t* kernel)
{
	if (r[1]<1e-4) {
		kernel[0] = 8*r[8]/735 + 24*r[6]/245 - 24*r[4]/35 + 8*r[2]/7 - 2./3;
		kernel[1] = -16*r[8]/8085 - 16*r[6]/735 + 48*r[4]/245 - 16*r[2]/35;
		kernel[2] = 32*r[8]/1617 + 128*r[6]/735 - 288*r[4]/245 + 64*r[2]/35 - 4./3;
		kernel[4] = 24*r[8]/2695 + 8*r[6]/105 - 24*r[4]/49 + 24*r[2]/35 - 2./3;
	}
	else if (r[1]>1e2) {
		kernel[0] = 2./105 - 24/(245*r[2]) - 8/(735*r[4]) - 8/(2695*r[6]) - 8/(7007*r[8]);
		kernel[1] = -16./35 + 48/(245*r[2]) - 16/(735*r[4]) - 16/(8085*r[6]) - 16/(35035*r[8]);
		kernel[2] = -44./105 - 32/(735*r[4]) - 64/(8085*r[6]) - 96/(35035*r[8]);
		kernel[4] = -46./105 + 24/(245*r[2]) - 8/(245*r[4]) - 8/(1617*r[6]) - 8/(5005*r[8]);
	}
	else {
		histo_t logr = 0.;
		if (my_abs(r[1]-1)>EPS) logr = my_log(my_abs((r[1] + 1)/(r[1] - 1)));
		kernel[0] = -1./84./r[1]*(2*r[1]*(19-24*r[2]+9*r[4])-9*power(r[2]-1,3)*logr);
		kernel[1] = 1./112./r[3]*(2*r[1]*(r[2]+1)*(3-14*r[2]+3*r[4])-3*power(r[2]-1,4)*logr);
		kernel[2] = 1./336./r[3]*(2*r[1]*(9-185*r[2]+159*r[4]-63*r[6])+9*power(r[2]-1,3)*(7*r[2]+1)*logr);
		kernel[4] = 1./336./r[3]*(2*r[1]*(9-109*r[2]+63*r[4]-27*r[6])+9*power(r[2]-1,3)*(3*r[2]+1)*logr);
	}
	kernel[3] = kernel[1];
}

void kernel_A_tA_1loop(size_t iq, histo_t mu_, histo_t pk_k, histo_t *kernel)
{
	histo_t x_ = gauss_legendre_q.x[iq];
	histo_t k = gauss_legendre_q.k;
	histo_t q = gauss_legendre_q.q[iq];
	
	histo_t x[9],mu[5];
	powers(x_,x,9); powers(mu_,mu,5);
	histo_t xmu = 1.+x[2]-2.*mu[1]*x[1];
	histo_t kq = gauss_legendre_q.k*my_sqrt(xmu);
	
	histo_t pk_q = gauss_legendre_q.pk[iq];
	histo_t pk_kq;
	find_pk_lin(&kq,&pk_kq,1,precision_mu.interpol);
	pk_kq /= xmu*xmu;
	
	histo_t kernel_A[NCOMP],kernel_At[NCOMP];
	A_mat(x,mu,kernel_A);
	At_mat(x,mu,kernel_At);
	
	size_t ii;
	//Taruya 2010 (arXiv 1006.0699v1) eq A3
	for (ii=0;ii<NCOMP;ii++) kernel[ii] = (kernel_A[ii] * pk_k + kernel_At[ii] * pk_q) * pk_kq;
}


void set_precision_A_1loop_q(size_t n_,histo_t min_,histo_t max_,char* interpol_)
{
	set_precision(&precision_q,n_,min_,max_,interpol_);
}

void set_precision_A_1loop_mu(size_t n_,char* interpol_)
{
	set_precision(&precision_mu,n_,-1.,1.,interpol_);
}

void init_A_1loop()
{
	init_gauss_legendre_q(&gauss_legendre_q,&precision_q);
	init_gauss_legendre_mu(&gauss_legendre_mu,&precision_mu);
}


void free_A_1loop()
{
	free_gauss_legendre_q(&gauss_legendre_q);
	free_gauss_legendre_mu(&gauss_legendre_mu);
}

static _Bool set_mu_range(histo_t x)
{
	histo_t xmin = gauss_legendre_q.x[0];
	histo_t xmax = gauss_legendre_q.x[gauss_legendre_q.nq-1];
	histo_t mumin = MAX(-1.,(1.+x*x-xmax*xmax)/2./x);
	histo_t mumax = MIN(1.,(1.+x*x-xmin*xmin)/2./x);
	if ((mumin>=1.)||(mumax<=-1.)||(mumax<=mumin)) return 0;
	update_gauss_legendre_mu(&gauss_legendre_mu,mumin,mumax);
	return 1;
}

void calc_pkcorr_from_A_1loop(histo_t k,histo_t* pkcorr_A)
{
	update_gauss_legendre_q(&gauss_legendre_q,k);
	
	size_t ii,iq,nq=gauss_legendre_q.nq;
	for (ii=0;ii<NCOMP;ii++) pkcorr_A[ii] = 0.;
		
	for (iq=0;iq<nq;iq++) {
	
		histo_t x = gauss_legendre_q.x[iq];
		if (!set_mu_range(x)) continue;
		
		histo_t integ_A_tA[NCOMP]={0.};
		histo_t kernel_A_tA[NCOMP];
		size_t imu,nmu=gauss_legendre_mu.nmu;	
	
		for (imu=0;imu<nmu;imu++) {
			kernel_A_tA_1loop(iq, gauss_legendre_mu.mu[imu], kernel_A_tA);
			histo_t w = gauss_legendre_mu.w[imu];
			for (ii=0;ii<NCOMP;ii++) integ_A_tA[ii] += kernel[ii]*w;
		}
		histo_t integ_a[NCOMP];
		kernel_a_1loop(x,integ_a);
		histo_t pk_q = gauss_legendre_q.pk[iq];
		histo_t w = gauss_legendre_q.w[iq];
		for (ii=0;ii<NCOMP;ii++) pkcorr_A[ii] += (integ_A_tA[ii]+integ_a[ii]*pk_k*pk_q)*w; 
	}
	
	histo_t factor = k*k*k / (4.*M_PI*M_PI);
	for (ii=0;ii<NCOMP;ii++) pkcorr_A[ii] *= factor;

}
